### functools.wraps 

```functools.wraps``` 是Python标准库中拿来即用的装饰器之一。虽然这不是这篇文章的重点，但还是举个例子：

```
def clock(func):
    time0 = time.time()

    @functools.wraps(func)
    def clocked(*args, **kwargs):
        t0 = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - t0
        name = func.__name__
        arg_lst = []
        if args:
            arg_lst.append(', '.join(repr(arg) for arg in args))
        if kwargs:
            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]
            arg_lst.append(', '.join(pairs))
        arg_str = ', '.join(arg_lst)
        print('[{:.8f}] {}({}) -> {}'.format(elapsed, name, arg_str, result))
        return result
    time1 = time.time()
    print('{:.5f}'.format(time1-time0))
    return clocked
```
在这里，```@functools.wraps()```里面传入的func就是被这个装饰器包装的函数，在使用时调用这个装饰器即可。

### functools.lru_cache

```functools.lru_cache```是非常实用的装饰器，它实现了备忘功能。这是一项优化技术，它把耗时的函数结果保存起来，避免传入相同的参数时的重复计算。
LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限增长，一段时间不用的缓存条目会被扔掉。我们现在来实现一个斐波拉契数列：

```
@clock
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-2) + fibonacci(n-1)
if __name__=='__main__':
    print(fibonacci(6))
```
运行结果：

```
0.00002
[0.00000119] fibonacci(0) -> 0
[0.00000095] fibonacci(1) -> 1
[0.00004601] fibonacci(2) -> 1
[0.00000000] fibonacci(1) -> 1
[0.00000000] fibonacci(0) -> 0
[0.00000095] fibonacci(1) -> 1
[0.00002813] fibonacci(2) -> 1
[0.00005388] fibonacci(3) -> 2
[0.00013494] fibonacci(4) -> 3
[0.00000095] fibonacci(1) -> 1
[0.00000119] fibonacci(0) -> 0
[0.00000072] fibonacci(1) -> 1
[0.00002599] fibonacci(2) -> 1
[0.00005198] fibonacci(3) -> 2
[0.00000000] fibonacci(0) -> 0
[0.00000072] fibonacci(1) -> 1
[0.00006986] fibonacci(2) -> 1
[0.00000000] fibonacci(1) -> 1
[0.00000000] fibonacci(0) -> 0
[0.00000000] fibonacci(1) -> 1
[0.00002813] fibonacci(2) -> 1
[0.00005603] fibonacci(3) -> 2
[0.00015402] fibonacci(4) -> 3
[0.00022912] fibonacci(5) -> 5
[0.00039196] fibonacci(6) -> 8
8
```

我们可以看到在这行这个函数的时候大部分时间都是装饰器在执行重复的操作，如果我们把装饰器的操作缓存起来就会有更好的体验。

```
@functools.lru_cache() # 这里引入缓存，实现更高的执行速度
@clock
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 2) + fibonacci(n - 1)


if __name__ == '__main__':
    print(fibonacci(6))
```

执行结果：

```
0.00002
[0.00000000] fibonacci(0) -> 0
[0.00000000] fibonacci(1) -> 1
[0.00002813] fibonacci(2) -> 1
[0.00000095] fibonacci(3) -> 2
[0.00004625] fibonacci(4) -> 3
[0.00000095] fibonacci(5) -> 5
[0.00006390] fibonacci(6) -> 8
8
```

可以看到这个函数的执行过程大大减少了，虽然执行时间变化很小(这里只取了5位小数位,差别并不明显)，那是因为这里只是生成了6次的斐波拉切数，如果是100次，
差别会是非常非常大的。

另外有几个注意的地方：

1. ```functools.lru_cache()```有两个参数，签名是```functools.lru_cache(maxsize=128, typed=False)```，```maxsize```指定存储多少个
调用的结果，缓存满了之后，旧的结果会被扔掉，腾出显得空间。为了得到最佳的性能，maxsize应该设为2的幂，默认为128。如果设置为 None 的话就相当于是
```maxsize```为正无穷。```type```参数设为```True```，会把不同类型的结果分开保存，即把通常认为想等的浮点数和整数类型(如1和1.0)区分。

2.因为```lru_cache```使用字典存储结果，而且键根据传入的定位参数和关键字参数创建，所以被```lru_cache```装饰的函数，它的所有参数必须是可散列的。

3.被```lru_cache```装饰的函数会有```cache_clear```和```cache_info```两个方法，分别用于清除缓存和查看缓存信息

### functools.singledispatch

因为Python不支持方法的重载，在Pyhon3.4版本之后新增了```functools.singledispatch```装饰器，它可以把整体方案拆分成多个模块，甚至可以为你无法修改的
类提供专门的函数。使用```@singledispatch```装饰的普通函数会变成泛函数(generic function)：根据第一个参数的类型，以不同的方式执行相同操作的一组函数。
采用[Python官方文档](https://www.python.org/dev/peps/pep-0443/)的例子：

```
from decimal import Decimal
from functools import singledispatch


@singledispatch
def fun(arg, verbose=False):
    if verbose:
        print("Let me just say,", end=" ")
    print(arg)


@fun.register(int) # 各个函数专门使用@«base_function».register(«type»)装饰
def _(arg, verbose=False):
    if verbose:
        print("Strength in numbers, eh?", end=" ")
    print(arg)


@fun.register(list)
def _(arg, verbose=False):
    if verbose:
        print("Enumerate this:")
    for i, elem in enumerate(arg):
        print(i, elem)


@fun.register(float)
@fun.register(Decimal)
def fun_num(arg, verbose=False):
    if verbose:
        print("Half of your number:", end=" ")
    print(arg / 2)


def nothing(arg, verbose=False):
    print("Nothing.")


fun.register(type(None), nothing) # 另一种注册的方式

if __name__ == '__main__':
    fun("hello,world")
    fun("test.", verbose=True)
    fun(42, verbose=True)
    fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)
    fun(None)
    fun(1.23)
```

执行结果：

```
hello,world
Let me just say, test.
Strength in numbers, eh? 42
Enumerate this:
0 spam
1 spam
2 eggs
3 spam
Nothing.
0.615
```


